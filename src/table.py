import functools

import tabulate

from typing import List, Dict, Any
from dtypes import Dtype
from pandas import Series
from exceptions import Overflow, InvalidType, TableConsistencyError


def validator(func):
    """
    Validate table initialization proccess if necessary

    """

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # If no validate argument, validation skips.
        # Enhance perfomace when table is reading from already validated file
        if not kwargs['validate']:
            kwargs['data'] = converter(kwargs['data'])  # Convert List data into List[Series]
            return func(*args, **kwargs)

        dtypes: Dict[Any, Dtype] = kwargs['dtypes']
        columns = kwargs['columns']
        try:  # Columns validation
            Table.validate_columns(columns)
        except TableConsistencyError as e:
            raise e

        for row in kwargs['data']:  # Validate each data point
            for i, col in enumerate(columns):
                try:
                    dtypes[col].validate(row[i])
                except Overflow as e:
                    raise e
                except InvalidType as e:
                    raise e
        kwargs['data'] = converter(kwargs['data'])  # Convert List data into List[Series]

        return func(*args, **kwargs)

    return wrapper


def converter(data: List[Any]):
    series = []
    for i in range(len(data[0])):
        series.append(Series([x[i] for x in data]))
    return series


class Table:
    MAX_COLUMN_NAME_LENGTH = 256

    @validator
    def __init__(self, data: List[Any], schema: str, uid: str,
                 name: str, dtypes: Dict[Any, Dtype], columns: List['str'], validate: bool = False,
                 force: bool = False):
        """
        :param data: Array-like object, represents data row-by-row, each i-th index inside row corresponds to
        particular column with i-th index and it's data type in dtypes argument
        :param schema: String name of schema
        :param uid: Autogenerated string 5-bytes uid
        :param name: String table name
        :param dtypes: Map of dtypes in Dict{'col_name': dtypes.Dtype} form
        :param columns: List of string named columns
        :param validate: Bool parameter determines whether validation need or not
        :param force: Force disable convertion process (e.x. data is already in consistent form
        """
        self.data: List[Series] = data
        self.schema = schema
        self.uid = uid
        self.name = name
        self.dtypes: Dict[Any, Dtype] = dtypes
        self.columns = columns

    @property
    def shape(self) -> tuple:
        return len(self.columns), len(self.data[0])

    def print(self, j=5) -> None:
        j = self.shape[1] if j > self.shape[1] else j
        headers = self.columns
        print(tabulate.tabulate([[x[i] for x in self.data] for i in range(j)], headers))

    @classmethod
    def validate_columns(cls, columns: List[str]):
        for col in columns:
            if len(col) > cls.MAX_COLUMN_NAME_LENGTH:
                raise TableConsistencyError(f'Column {col} name is greater than {cls.MAX_COLUMN_NAME_LENGTH}')

    def __str__(self):
        return f'Name: {self.name}\nColumns: {self.columns}, dtypes: {self.dtypes}, size: {self.shape}'

    def __iter__(self):
        for i in range(self.shape[1]):
            yield [x[i] for x in self.data]
